import React, { useState, useEffect, useRef } from "react";
import "../styles/FractionMatch.css";

export default function FractionMatch() {
  const [pos, setPos] = useState({ x: 50, y: 5 });
  const [velocity, setVelocity] = useState({ vx: 0, vy: 0.2 });
  const [gameOver, setGameOver] = useState(false);
  const [lives, setLives] = useState(3);
  const [streak, setStreak] = useState(0);
  const [score, setScore] = useState(0);
  const [feedback, setFeedback] = useState({ type: null, message: "" });
  const [userInput, setUserInput] = useState("");
  const [targetFraction, setTargetFraction] = useState({ numerator: 1, denominator: 2 });
  const [gameComplete, setGameComplete] = useState(false);

  const animationRef = useRef(null);
  const vxRef = useRef(0);
  const vyRef = useRef(0);
  const livesRef = useRef(lives);
  const gameOverRef = useRef(gameOver);

  useEffect(() => { livesRef.current = lives; }, [lives]);
  useEffect(() => { gameOverRef.current = gameOver; }, [gameOver]);

  // Utility: simplify a fraction
  const simplifyFraction = (numerator, denominator) => {
    const gcd = (a, b) => (b ? gcd(b, a % b) : a);
    const divisor = gcd(numerator, denominator);
    return {
      numerator: numerator / divisor,
      denominator: denominator / divisor,
    };
  };

  // Random fraction generator
  const generateFraction = () => {
    const denominator = 2 + Math.floor(Math.random() * 12);
    const numerator = 1 + Math.floor(Math.random() * (denominator - 1));
    return { numerator, denominator };
  };

  // Random downward angle between 30¬∞‚Äì150¬∞
  const getRandomAngle = () => 30 + Math.random() * 120;

  const startNewRound = (reset = false) => {
    const newFraction = generateFraction();
    setTargetFraction(newFraction);
    setFeedback({ type: null, message: "" });
    setUserInput("");
    setGameOver(false);
  
    // constant X position
    const startX = 50;
  
    // random downward angle
    const angle = 30 + Math.random() * 120;
    const speed = 0.45; // constant speed
    const vx = Math.cos((angle * Math.PI) / 180) * speed * (Math.random() < 0.5 ? 1 : -1);
    const vy = Math.sin((angle * Math.PI) / 180) * speed;
  
    vxRef.current = vx;
    vyRef.current = vy;
    setPos({ x: startX, y: 5 });
    setVelocity({ vx, vy });
  
    if (reset) {
      setLives(3);
      setScore(0);
      setStreak(0);
      setGameComplete(false);
    }
  
    cancelAnimationFrame(animationRef.current);
  
    const loop = () => {
        setPos((prev) => {
          let newX = prev.x + vxRef.current;
          let newY = prev.y + vyRef.current;
      
          // Bounce off left/right walls
          if (newX <= 5 || newX >= 95) {
            vxRef.current *= -1;
            newX = Math.min(Math.max(newX, 5), 95);
          };
          
          // If it hits the bottom
          if (newY >= 95) {
            cancelAnimationFrame(animationRef.current);
            console.log("in newy=90 loop");
            if (livesRef.current <= 1) {
              setGameOver(true);
              setGameComplete(true);
            }
            else {
              livesRef.current -= 1; // subtract **once**
              setLives(livesRef.current);
              console.log("Life lost");
              setStreak(0);
              // schedule next round
              setTimeout(() => startNewRound(), 800);
            }
      
            return { x: newX, y: 90 };
          }
      
          return { x: newX, y: newY };
        });
      
        if (!gameOverRef.current) animationRef.current = requestAnimationFrame(loop);
    };

    animationRef.current = requestAnimationFrame(loop);
  };
  
  
  

  useEffect(() => {
    startNewRound(true);
  }, []);

  useEffect(() => {
    let lastTime = performance.now();

    const loop = (time) => {
      lastTime = time;

      setPos((prev) => {
        let newX = prev.x + vxRef.current;
        let newY = prev.y + vyRef.current;

        // Bounce off left/right walls
        if (newX <= 5 || newX >= 95) {
          vxRef.current *= -1;
          newX = Math.min(Math.max(newX, 5), 95);
        }

        // If it hits the bottom
        if (newY >= 90) {
          cancelAnimationFrame(animationRef.current);

          if (livesRef.current <= 1) {
            setGameOver(true);
            setGameComplete(true);
          } else {
            setLives((prev) => prev - 1);
            setStreak(0);

            // restart next round reliably after 0.8s
            setTimeout(() => {
              startNewRound();
              animationRef.current = requestAnimationFrame(loop);
            }, 800);
          }

          return { x: newX, y: 90 };
        }

        return { x: newX, y: newY };
      });

      if (!gameOverRef.current) animationRef.current = requestAnimationFrame(loop);
    };

    animationRef.current = requestAnimationFrame(loop);
    return () => cancelAnimationFrame(animationRef.current);
  }, []);

  // Check if two fractions are equivalent
  const checkEquivalent = (input) => {
    const fractionRegex = /^\s*(\d+)\s*\/\s*(\d+)\s*$/;
    const match = input.match(fractionRegex);
    if (!match) return false;
    const num = parseInt(match[1]);
    const den = parseInt(match[2]);
    if (den === 0) return false;
    const simpInput = simplifyFraction(num, den);
    const simpTarget = simplifyFraction(targetFraction.numerator, targetFraction.denominator);
    return simpInput.numerator === simpTarget.numerator && simpInput.denominator === simpTarget.denominator;
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    if (feedback.type || !userInput.trim()) return;

    const correct = checkEquivalent(userInput);

    if (correct) {
      const newStreak = streak + 1;
      const earned = newStreak;
      setStreak(newStreak);
      setScore((s) => s + earned);
      setFeedback({ type: "correct", message: `‚úÖ Correct! +${earned} point${earned > 1 ? "s" : ""}` });
      setTimeout(() => startNewRound(), 1000);
    } else {
      setFeedback({ type: "wrong", message: "‚ùå Wrong" });
      setStreak(0);
    }
  };

  if (gameComplete) {
    return (
      <div className="fm-game-over-page">
        <div className="fm-game-over">
          <h2>üèÜ Game Over! üèÜ</h2>
          <div className="fm-score-summary">
            <p>
              Final Score: <span className="fm-final-score">{score}</span>
            </p>
            <p>
              Longest Streak: <span className="fm-streak-highlight">{streak}</span>
            </p>
          </div>
          <button
            className="fm-button"
            onClick={() => startNewRound(true)} // ‚úÖ Reset everything and restart animation
          >
            Play Again
          </button>
        </div>
      </div>
    );
  }
  

  return (
    <div className="fm-container">
      <h1 className="fm-title">Fraction Match</h1>

      <div className="fm-stats">
        <div className="fm-score-display">
          <div>
            Score: <span className="fm-score-value">{score}</span>
          </div>
          <div className="fm-streak">
            üî• Streak: <span className="fm-streak-count">{streak}</span>
          </div>
        </div>
        <div className="fm-lives">
          {Array.from({ length: 3 }).map((_, i) => (
            <span key={i} className={`fm-heart ${i < lives ? "active" : "inactive"}`}>
              {i < lives ? "‚ù§Ô∏è" : "üñ§"}
            </span>
          ))}
        </div>
      </div>

      <div className="fm-question-box">
        <p className="fm-question">
          Enter an equivalent fraction to {targetFraction.numerator}/{targetFraction.denominator}:
        </p>
        <form onSubmit={handleSubmit}>
          <input
            type="text"
            value={userInput}
            onChange={(e) => setUserInput(e.target.value)}
            placeholder="e.g., 2/4"
            className="fm-input"
            disabled={!!feedback.type && !gameOver}
            autoFocus
          />
          <button
            type="submit"
            className="fm-button"
            disabled={!userInput.trim() || (!!feedback.type && !gameOver)}
          >
            Submit
          </button>
        </form>
        {feedback.type && <div className={`fm-feedback ${feedback.type}`}>{feedback.message}</div>}
      </div>

      <div className="fm-space">
        <div
          className="fm-fraction"
          style={{
            left: `${pos.x}%`,
            top: `${pos.y}%`,
            transform: "translate(-50%, -50%)",
          }}
        >
          {targetFraction.numerator}/{targetFraction.denominator}
        </div>
      </div>

      {gameOver && (
        <button className="fm-button" onClick={() => startNewRound()}>
          Next Round
        </button>
      )}
    </div>
  );
}
